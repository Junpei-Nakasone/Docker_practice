# Docker_memo  

`docker run --name コンテナ名 -d \  
-p ホストのポート番号:コンテナのポート番号 \
イメージ名`  

#### --name  

#### nginxでhttpメソッド制限するには  
起動中のnginxのdefault.confをコピーして取得  
`docker cp tmp-nginx:etc/nginx/conf.d/default.conf ./`  

ローカルのディレクトリでdefault.confの設定を変更  
`  location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        limit_except POST {
        deny all;
}`  

 
default.conf をコピーするDockerfileを作成
`FROM nginx:latest
COPY default.conf /etc/nginx/conf.d/default.conf`  
  
  
イメージをbuild  
`docker build -t nginx:ver1 .`  

作成したイメージからコンテナを実行  
`docker run --name web -p 8080:80 --rm nginx:ver1`


# docker-compose  
webサーバー、DBサーバー、キャッシュサーバーなど定義を一つのymlファイルに記述しておくことで、そのymlファイルを基にアプリケーションに必要なコンテナをまとめて起動できる  

#### ymlとは  
構造化されたデータを表現するためのフォーマット。直感的に書かれているのでファイルを見れば構造は大体理解できる。  
##### Compose実行ステップ  
1. Docker imageをビルドするためのDockerfileを用意するか、使用するイメージをDocker Hubなどに用意する  
2. docker-compose.ymlを定義する。このファイルにコンテナ毎の起動時の設定を書き込む。これはdocker-runコマンドで各種設定をするようなもの。  
3. docker-compose.ymlを置いてあるディレクトリでdocker-compose upを実行する。単純にdocker-compose upだとフォアグラウンドで起動するので、実際には-dをつけてデタッチドモードで起動することが多い。コマンドを実行するとdocker-compose.ymlの設定に従って各コンテナが実行される。  

# Dockerにおけるデータ管理について
コンテナで扱う動的なデータは起動中のコンテナの読み書き可能なレイヤーに置くこともできるが、いくつかのデメリットがある。例えば、コンテナが削除された時点でコンテナに置いてあったデータが消えたり、コンテナ間でデータを共有することができない、など。そのほかに書き込みのパフォーマンスもホスト上にデータを書き込むのに比べて、書き込みのパフォーマンスが良くない。これは、コンテナへの読み書き可能なレイヤーへの書き込みは、通常のファイルシステムとは異なるUnion Filesystemが利用されているため。
Dockerにはホスト上のディレクトリやファイルをコンテナにマウントする仕組みや、ホストのメモリをファイルシステムとしてコンテナにマウントする仕組みが用意されている。


# Dockerでできること  
#### 開発環境の構築  
よくあるアプリケーションの開発の現場では、開発環境を構築する場合に、それぞれのメンバーが開発言語の動作環境を用意し、DBサーバーを構築するという作業が発生します。開発者一人一人がそういう作業を行うと、それぞれがインストールしたミドルウェアのバージョンに差異が生じ、環境依存によって動作しないケースが発生したり、環境構築そのものに時間がかかってしまうなどの問題が起こりがち。  
Dockerで開発環境を用意できれば、そういう作業がものすごく簡単になる。また、アプリケーション実行環境の立ち上げがスピーディーになる。  
Dockerを使用して開発環境を作れるようになることで、新しい言語やDBなどを触ってみたい場合に、検証環境を簡単に立ち上げることができるので、これからすごく役に立つスキルになる。  

#### クラウド環境にDockerコンテナをデプロイする  
本番環境でアプリを動かす場合、AWSやGCPを利用することが多い。そこで、自分のPCで動作したものをクラウド環境で動作させる際に、Dockerが役立つ。  


### コンテナ型仮想化の特徴  
特定のアプリケーションを動作させるために必要なものはDockerイメージにまとまっているので、同じDockerイメージからコンテナを起動する限り、環境が変わっても同じ動作をする。  

#### 分離レベル  
コンテナ型仮想化はOSの機能を使用しているので、従来の仮想化に比べて分離レベルは低い。要求されるセキュリティレベルの高いシステムでは懸念点になり得る？侵入されにくい設定や構成にするため、不用意にパブリックに公開しない、不必要なパッケージをインストールしない、脆弱性のあるライブラリをアップデートするなど対策が必要。  

# Dockerイメージとは  
コンテナ実行に必要なファイルをまとめたファイルシステム。イメージ含まれるのは、OSのライブラリやアプリケーションなど。例えばwebサーバーならnginxが既に取得されているイメージが使用できる。  
プログラムの実行環境も、PHPやRubyが既にk取得されているイメージを使えば簡単に実行環境を用意できる。  
Dockerイメージはレイヤーという階層構造でファイルが管理される、少し変わったファイルシステム。  
イメージのレイヤはデータで構成され、読み取り専用となっている。  
Dockerイメージを基にコンテナを起動すると、新たにコンテナレイヤーという層が作られる。Dockerイメージからコンテナを起動して、コンテナレイヤー上にパッケージの追加などを行い、それを新しくイメージとして保存することも可能。  
Dockerコンテナはなるべく軽量にサイズを抑えることが重要とされており、無駄なファイルがイメージの中に含まれないようにイメージを作成する必要がある。  

Dockerイメージが大きくなるということは、イメージのダウンロードやDockerHubへのアップロードに時間がかかるようになる。Dockerを使用するメリットに軽量ですぐに環境を立ち上げられることなので、Dockerイメージが大きいと、そのメリットが薄くなってしまう。  

Dockerイメージは複数のイメージで継承環境を作ることができる。

# イメージビルド  
イメージの定義ファイルであるDockerfileを作成し、Dockerイメージを構築する。これをイメージビルドという。

```Dockerfile
# Dockerfileでは命令の後に引数を与える

# FROMはイメージを作成する際に基になるイメージを指定する命令
# 基になるイメージの上に新しいレイヤーを重ねてカスタマイズする
FROM docker/whalesay:latest

# ubuntuがベースになっているイメージではapt-getが使える
# RUN命令はイメージビルドの際に実行するコマンドを指定する命令
# apt-get でアップデートした後に、fortunesパッケージのインストールを実行する。-yオプションをつけることで、yes/noを自動でyesにする。
RUN apt-get -y update && apt-get install -y fortunes

# CMD命令はコンテナが作成された後で実行するコマンドを指定する命令
# インストールしたfortuneコマンドを実行して、その結果出力される文章を|(パイプ)でcowsayコマンドに渡している。結果、コンテナ起動時に鯨のアスキーアートが表示され格言を話す。
CMD /usr/games/fortune | cowsay
```  

Dockerfileができたらdocker buildでイメージをビルドする  

```
$docker build -t docker-test .
```
#### build 
イメージをビルドするサブコマンド  
#### -t docker-test 
タグ名の指定
#### . 
ビルドコンテキストの指定。.を指定することでカレントディレクトリを参照する。イメージ内に含めたいファイルやディレクトリがある場合はこのビルドコンテキスト内のファイルからコピーすることができる。
逆にビルドコンテキスト外のファイルはイメージ構築時に参照できない。また、イメージビルド時にビルドコンテキストのファイルやディレクトリはまとめてDockerデーモンい送信される。大きなファイルがビルドコンテキストに含まれる場合、このファイルの転送処理にかなり時間がかかるので、不要なファイルはビルドコンテキストに含まないようにする。


# Dockerコンテナを立ち上げるコマンド  
```
$docker run --name <コンテナ名> -d \
-p <ホスト側のポート番号>:<コンテナ側のポート番号> <イメージ名>
```